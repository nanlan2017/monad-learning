
transformer 的逻辑：
    通过为 每一个结果的产生 附加上m 这个隐式状态， 从而组合 “同时存在的两个隐式状态”  （ 是 正交的啊、两块 状态互不影响！）



bind 的实质：
    实现对携带隐式状态的 m a     将其 结果 a 传入后续的 actions， 从而 “承接”对一个值的链式处理
     ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 
     ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 
                bind 两个连续action的方式： （提供参数/初始状态）让第一个action 执行，然后将其结果a 值送入后续的 Action、并执行第二个action， 得到第二个 res+ side-effect
                                          那么 这两行作为action的“绑定”就是  上述过程。
    ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
    ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  

{-———————————————————————————————————————————————————————————————————————————————————————————————————-}

举例来说 ：  
    ①   MaybeT  IO  a  =   IO (Maybe a)



    

    ②  NT  m   a  
        ---- 具体的实现取决于 N的隐式状态传递的逻辑， 但实现时按套路的。

        instance (Monad m)=>  Monad (NT m) where
            -- bind :: NT m a ->  (a-> NT m b) -> NT m b

            m >> k =  WrapNT $ do      // 此do 块必然对应 Monad m 、从而整个bind 行为就是基于Monad m 的行为之上了！（可以再复合其他行为）
                // 由于tranformer 都是把“结果类型” 加上了m， 
                // 我就可以按 原参数得到结果 m result ,   然后 用 <- 取出result、送入后续运算。
                // ▇▇▇▇▇▇ 因此： NT m 的 bind 实现 看起来和 N 这个 Monad 的实现很像，不过是在 该取“结果”的时候对应成用<- 取

{-———————————————————————————————————————————————————————————————————————————————————————————————————-}
为什么 NT m 可以实现继承 m 的 Monad 语义？

    比如： 当 m 是 MonadWriter 时，如何实现 StateT s m 的 Writer 行为？
            ———— 即实现 put/get 



    ▇▇▇▇▇▇ 举个实际的场景： 一段能 利用全局的 Seed 生成随机数、并同时书写 Log 的 业务代码，显然就是 state + writer
            ===================  想想其本质， 就是说  s -> m (a,s)  

{-———————————————————————————————————————————————————————————————————————————————————————————————————-}

RWST IO a  

就是说   有一组计算要把它们写成一段“大的do-Action”， 其中包含了以下几种模式的运算：
            ① 过程中的某些计算会 与 IO 交互，比如打印一下运算结果
            ② 过程中的某些计算 是要 读/改 全局状态 s 的
            ③ 有一个 只读的 Config 信息，可以在该大  Action 之间传递这个信息 （某些步骤需要用的话，可以 ask / local 来使用它！）
            ④ 某些步骤会 写 Log 
            ......
            ⑤ 某些步骤可能会失败 Maybe 。 （注意bind >>= 和 then >> 的利用）
