module ContTest where
add x y = x + y
{-
GHC.Base                        ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
        ($) :: (a->b) -> a -> b   ▇▇▇▇▇▇▇ 柯里化的partial apply 还可以 只赋第二个参数啊！！！  
                                        f :: a -> b -> c
                                        则  f va  :: b-> c
                                       还有  `f` vb :: a-> c
        f $ a = f a             ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇

        $ "ABC" :: (String->b)->b   // 把a 替换成 String  // $ v 则 v 是第二个参数！
        ($) "ABC"   // x 编译不通过，String 无法匹配a->b


        ▇▇▇▇▇▇▇  所以 ：      
                  va   ::  a
                $ va   ::  (a->r)->r

-}
t0 :: Int -> String -> [String]
t0 = replicate

t1 :: String -> [String]
t1 = replicate 5

t2 :: Int -> [String]  -- ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  只有对于 二元函数才是可能的 （只有二元函数（运算符函数） 才能 “中缀形式”调用 ）
t2 = (`replicate` "abc")
{-▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃-}
add_cps' :: Int -> Int -> ((Int -> r) -> r)
add_cps' x y fNext = fNext $ add x y
-- ▇▇▇▇▇▇▇▇▇▇▇▇▇ 加一个 $， 就完成了  f 到 f_cps 的变换
add_cps'' :: Int -> Int -> ((Int -> r) -> r)
add_cps'' x y = ($ (add x y))   -- $ vInt :: (Int->r)->r

f0 :: (Integer -> b) -> b
f0 = ($ 3)

f1 :: Integer -> String
f1 = ("abc" ++) . show

v1 :: String
v1 = f0 f1

v2 :: Integer
v2 = ($ 3) (+ 2)   -- (Integer->r)->r 【$3是高阶函数】    ++  (Integer->Integer)   --->  r
v3 = ($ 3) $ (+ 2)


v5 = (+ 2) $ 3    --中缀调用（第一个参数为 f ，第二个参数为x )
v4 = (+ 2) 3
v6 = ($) (+ 2) 3  --前缀调用

{-▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃▃-}
