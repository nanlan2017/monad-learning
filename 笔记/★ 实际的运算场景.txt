    ▇▇▇▇▇▇ 举个实际的场景： 一段能 利用全局的 Seed 生成随机数、并同时书写 Log 的 业务代码，显然就是 state + writer
                type App a = StateT Seed (Writer Logs) a = {runApp::  }
            ===================  想想其本质， 就是说  s -> m (a,s)  

{-———————————————————————————————————————————————————————————————————————————————————————————————————-}

RWST Config Logs Seed (MaybeT IO) a  


 ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 其 Monad Stack :
    Maybe
    IO 


    
            ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
            ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  
就是说   有一组计算要把它们写成一段“大的do-Action”， 其中包含了以下几种模式的运算：
            ① 过程中的某些计算会 与 IO 交互，比如打印一下运算结果
            ② 过程中的某些计算 是要 读/改 全局状态 s 的
            ③ 有一个 只读的 Config 信息，可以在该大  Action 之间传递这个信息 （某些步骤需要用的话，可以 ask / local 来使用它！）
            ④ 某些步骤会 写 Log 
            ......
            ⑤ 某些步骤可能会失败 Maybe 。 （注意bind >>= 和 then >> 的利用）
            ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 
            ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 