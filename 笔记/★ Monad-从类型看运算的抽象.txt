《Monad Challenges》让我认识到： Monad 类型就是从 一组运算 抽象出 它们的共同模式
    比如 ：   randInteger :: Seed -> (Integer,Seed)
             randLetter :: Seed -> (Char,Seed) 
        比较它们的类型，可发现：
             type Gen a = Seed -> (a,Seed)
             则
                randInteger :: Gen Integer
                randLetter ::  Gen Char
▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  从类型签名来看它们要抽象的那种运算 的特征

{-—————————————————————————————————————————————————————————————————————————————————————————————————————————————-————————————————————————-}


  Reader r a  ::   r -> a  
            参数里均包含一个 r 类型参数 的一组计算 （结果类型任意）
    举例：                                             ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
        load :: Config -> String -> IO String       (★<---- ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 显然从类型签名就能看出：这组计算的共同模式是： 这是个 Reader，且计算过程中有 IO 副作用的计算)
        loadRevision :: Config -> Int -> IO String        自然就是  ReaderT Config IO a ::   Config -> IO a
        loadAll :: Config -> Int -> String -> IO (String, String)   即  ReaderT r m  a ::   r -> m a



  Writer w a  ::   (a,w)
            计算结果里 均有个额外的 w 类型输出 的一组计算   (参数类型任意)
    举例：
    load :: Config -> String -> IO String



  State s a  ::  s -> (a,s)
            参数里均包含一个 S类型参数、同时计算结果里 也包含此 S 类型的额外输出 的一组计算 
    举例：
        rand :: Seed -> (Integer,Seed)
        randLetter :: Seed -> (Char,Seed) 

{-———————————————————————————————————————————————————————————————————————————————————————————————————————-——————————————————————————————-}

  Either e a ::  计算结果均包含两种可能性（出现某种异常 | 顺利计算） 的一组计算

  [a]   ::  计算结果均有多个可能的结果值（结果为列表） 的一组计算

  Maybe a  :: 计算结果均包含两种可能性 （崩溃 | 顺利计算）的一组计算                  
{-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-———————————————-}

  Cont r a  ::  (r->a) -> r
                参数里均包含一个函数 （该函数含有一个r型参数）、 结果为 r 类型的一组计算
                ——————>  这些运算的特点是：
                       由于 Cont (表示延续的 monad) 的性质, 被包装的函数和作这个函数参数的函数返回值必须相同, 因此 transformer 将两个值都包装入内层 monad 中

  bind ::  ((r->a)->r) -> (a->(r->b)->b) ->  (r->b)->b                     