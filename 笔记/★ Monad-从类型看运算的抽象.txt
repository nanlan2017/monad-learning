《Monad Challenges》让我认识到： Monad 类型就是从 一组运算 抽象出 它们的共同模式
    比如 ：   randInteger :: Seed -> (Integer,Seed)
             randLetter :: Seed -> (Char,Seed) 
        比较它们的类型，可发现：
             type Gen a = Seed -> (a,Seed)
             则
                randInteger :: Gen Integer
                randLetter ::  Gen Char
▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  从类型签名来看它们要抽象的那种运算 的特征

{-—————————————————————————————————————————————————————————————————————————————————————————————————————————————-————————————————————————-}


  Reader r a  ::   r -> a  
            参数里均包含一个 r 类型参数 的一组计算 （结果类型任意）
    举例：                                             ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
        load :: Config -> String -> IO String       (★<---- ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 显然从类型签名就能看出：这组计算的共同模式是： 这是个 Reader，且计算过程中有 IO 副作用的计算)
        loadRevision :: Config -> Int -> IO String        自然就是  ReaderT Config IO a ::   Config -> IO a
        loadAll :: Config -> Int -> String -> IO (String, String)   即  ReaderT r m  a ::   r -> m a



  Writer w a  ::   (a,w)
            计算结果里 均有个额外的 w 类型输出 的一组计算   (参数类型任意)
    举例：
    load :: Config -> String -> IO String



  State s a  ::  s -> (a,s)
            参数里均包含一个 S类型参数、同时计算结果里 也包含此 S 类型的额外输出 的一组计算 
    举例：
        rand :: Seed -> (Integer,Seed)
        randLetter :: Seed -> (Char,Seed) 

{-———————————————————————————————————————————————————————————————————————————————————————————————————————-——————————————————————————————-}

  Either e a ::  计算结果均包含两种可能性（出现某种异常 | 顺利计算） 的一组计算

  [a]   ::  计算结果均有多个可能的结果值（结果为列表） 的一组计算

  Maybe a  :: 计算结果均包含两种可能性 （崩溃 | 顺利计算）的一组计算                  
{-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-———————————————-}

   

  Cont r a  ::  (r->a) -> r
                参数里均包含一个函数 （该函数含有一个r型参数）、 结果为 r 类型的一组计算
                ——————>  这些运算的特点是：
                       ▇▇▇▇▇▇▇▇由于 Cont (表示延续的 monad) 的性质, 被包装的 那个函数：作这个函数参数的函数返回值必须相同, 因此 transformer 将两个值都包装入内层 monad 中

  bind ::  ((r->a)->r) -> (a->（(r->b)->b) ->  (r->b)->b      


{-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-———————————————-}
  CPS 风格： Continuation-Passing-Style ：   
    int i = add(5, 10);
    int j = square(i);

                改成： int j = add(5, 10, square);▇▇▇▇▇▇▇▇ 新的 add 函数的特点： 其有一个
                                                  ▇▇▇▇▇▇▇▇  注意： add 的结果类型已变！！


    System.out.println("Please enter your name: ");
    System.in.readLine();

                改成： System.out.println("Please enter your name: ", System.in.readLine);

{-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-———————————————-}

    规律：   前一个函数为  f1 :: a->b -> c
            而后一个函数  f2 原接受一个b 型参数，即  c-> d -> e   
                        f3 原为 e->f -> g

            原调用方式           f3 (f2 (f1  va  vb) vd) vf 得  vg


            ▇▇▇▇▇▇▇▇【现在每个函数的最后添加一个 参数，其参数类型与 本函数的返回值类型一致 】
                      f1' :: a->b ->(c-> X) -> X
                      f2' :: c->d ->(e-> Y) -> Y
                                                              //最后一个函数不用改写： f3' :: e->f ->(g-> Z) -> Z    
                        f3  :: e->f -> g

              推导：     f1' va vb f2'           :: d ->(e-> Y) -> Y     (这是 X 的替换)
                        f1' va vb f2' vd f3     :: f -> g              （这是 Y 的替换）
                        f1' va vb f2' vd f3 vf  :: g                    计算完成
                                                                        
            ▇▇▇▇▇▇▇▇  这种是建立在我已经手动改造了 f1 , f2, 到 f1' , f2' 才能这样写的
             ▇▇▇▇▇▇▇▇  目标： 通过 bind 自动实现 即    f1  va vb >>= f2 vd >>= f3 vf  :: g     

                      而   f2  vd  >>=  f3  vf  的类型表现为:
                           x  这种思路不对

                           而是    (r->a)->r   >>=   a->(r->b)->r    ::   (r->b)->r 
                           显然： a 是一个环节往后面传的结果类型，对应 X,Y
{-——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-———————————————-}

add :: Int -> Int ->Int 
