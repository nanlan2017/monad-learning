(a,w)               变为    m (a,w)

r->a                变为    r-> m a

s->(a,s)            变为    s-> m (a,s)

r -> s -> (a,w,s)   变为    r ->s -> m (a,w,s)

(a->r)->r           变为    (a->m r)-> m r


Maybe a             变为    m (Maybe a)
Either e a          变为    m (Either e a)
[a]                 变为    m [a]


▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  发现了变形规律： 把每一个 对应“结果类型” 前面都加上了m ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇
▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇                       
                        即：  
                        ① 如果只有孤零零的a ，则a 本就对应“计算结果” ——————> 变成 m a ,   
                        ② a->b 中 b 对应“计算结果”  ——————> 变成 a -> m b
                        ③ 所有对应“计算结果”的那个类型都要变 （注意 Cont Monad里就是这样的)

 ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇  而其中的语义就是：说明结果的产生 是伴随着副作用的。   让其中每个计算的结果产生都具备了基于 Monad m 的隐式状态。            
                          把所有 m 都换成 IO 就更好理解了！ （m 就是表明这个结果是要从隐式状态中来的！）               



{-——————————————————————————————————————— 友情回顾之前认识 ——————————————————————————————————————————————————-}
之前认识到的：
            a -> b   和 a -> m b 其实都是 ： 由a 计算得到结果b
                                不同在于：后者的m b 相当于 "b with side-effect" : 即表明 b 是一个 伴随着有副作用的 Action 得到的结果


 所以从类型签名来看   f :: a->b -> c  和 g ::a->b -> m c
 就能知道：  g 的c 是要经过副作用才计算出来的、具有“隐式状态”                                

{-———————————————————————————————————————————————————————————————————————————————————————————————————-}

