
{-❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑
-- ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 《 一段命令式运算过程的抽象：理解 Action a -> (a->Action b) -> Action b 》
    想像一段 C++程序： 
                首先存在全局的状态变量 s0，
                action1 执行时会修改这些环境变量 : 在 s0 => (a,s1)中  就体现着状态s 被修改，并action1也会计算出结果a
                接下来，action2同样依赖/修改这些环境变量，（所以是 s1 => (b,s2) 。 而且其还可以使用上一步action1的计算结果a

    整个系统的状态总和变化 ： s0  ---(act1)--->  a, s1 ---(act2)---> b, s2
    就是说：结合 act1 和act2后，得到了一个从 s0 -> (b, s2) 的合成的action

   ▇▇▇▇▇▇▇▇▇ a -> Action b 的意思理解为： 在 Action发生前，除了系统状态 S外还有一个代表之前的局部结果 a  , 而 接下来后方的 Action-s 会用到这个 a 
                                                                                        （顺序式的计算过程肯定是 在前面的局部基础上继续啊！）


❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖
▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇   m a -> (a-> m b) 的由来  ： 这个 “a->"  只是意味着 ： 让前面的结果a 对 后续的 Actions 可见（如同全局状态）
显然，正确的串联方式： (让Action 接连发生)
  do 
     ra <-  Action1 a
     Action-s b  (可见ra)
     ...

  不用do的话：
    Action1 a  >>=    \ra ->
    Action-s b   (可见ra)

 变成：
    Action1 a  >>=             <---  m  a
    \ra ->   Action-s b        <---  a -> m b                                                                           
❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖❖
    -- Action-s 执行前存在着全局状态 s                                                                                        
    -- Action-s 执行前存在着前面的运算结果 a   （作为 附加的“全局状态”）
            a -> s -> (b,s)                                                                                      
    -- Action-s 执行后会产生一个结果： b
    -- Action-s 执行后还会有副作用：s'                                                                                    
❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑❑-}